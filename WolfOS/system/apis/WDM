--[[WolfOS is the intellectual property of James Chapman (toxic.wolf@hotmail.co.uk).
Please ask for permission before attempting to redistribute any code relating to WolfOS IN ANY FORM.]]--

--WolfOS Data Management Library

function exists(sPath)
	local hFile = io.open(sPath, "r")
	if hFile then
		hFile:close()
		return true
	end
	return false
end

function readToTable(sPath)
	if exists(sPath) then
		local hFile = io.open(sPath, "r")
		local tLines = {}
		local sLine = ""
		local i = 1
		repeat
			sLine = hFile:read()
			tLines[i] = sLine
			i = i + 1
		until not sLine
		hFile:close()
		return tLines
	end
	return {}
end

function readLine(sPath, nLine)
	if exists(sPath) then
		local tLines = readToTable(sPath)
		return tLines[nLine]
	end
	return ""
end

function readAllText(sPath)
	if exists(sPath) then
		local hFile = io.open(sPath, "r")
		return hFile:read("*a")
	end
	return ""
end

function fWrite(sPath, sText)
	local hFile = io.open(sPath, "w")
	hFile:write(tostring(sText))
	hFile:close()
end

function fWriteFromTable(sPath, tTable)
	local sText = ""
	for n = 1, #tTable do
		sText = sText .. tTable[n] .. "\n"
	end
	fWrite(sPath, sText)
end

function fWriteAtStart(sPath, sText)
	local _sText = readAllText(sPath)
	fWrite(sPath, sText .. "\n" .. _sText)
end

function fWriteAtStartFromTable(sPath, tTable)
	local sText = ""
	for n = 1, #tTable do
		sText = sText .. tTable[n] .. "\n"
	end
	fWriteAtStart(sPath, sText)
end

function fAppend(sPath, sText)
	local hFile = io.open(sPath, "a")
	hFile:write(sText .. "\n")
	hFile:close()
end

function fAppendFromTable(sPath, tTable)
	local sText = ""
	for n = 1, #tTable do
		sText = sText .. tTable[n] .. "\n"
	end
	fAppend(sPath, sText)
end

function replaceLine(sPath, nLine, sText)
	local tLines = readToTable(sPath)
	tLines[nLine] = sText
	fWriteFromTable(sPath, tLines)
end

function removeLine(sPath, nLine)
	local tLines = readToTable(sPath)
	table.remove(tLines, nLine)
	fWriteFromTable(sPath, tLines)
end

function getFileType(sPath)
	local tExtensions = {[".dat"] = "data", [".txt"] = "text", [".lib"] = "library", [".prj"] = "project"}
	if exists(sPath) and tExtensions[string.sub(sPath, #sPath - 3)] then
		return tExtensions[string.sub(sPath, #sPath - 3)]
	end
	return nil
end

function getRoot()
	return "/WolfOS/"
end

function getSystemDir()
	return getRoot() .. "system/"
end

function getSystemDataDir()
	return getSystemDir() .. "data/"
end

function getUtilitiesDir()
	return getRoot() .. "utilities/"
end

function getProgramsDir()
	return getRoot() .. "programs/"
end

function getUsersDir()
	return getRoot() .. "users/"
end

function getDataDir(sProgram)
	local sProgram = sProgram or ""
	return getRoot() .. "appdata/pers/" .. sProgram .. "/"
end

function getTempDir(sProgram)
	local sProgram = sProgram or ""
	return getRoot() .. "appdata/temp/" .. sProgram .. "/"
end

function readSystemTemp(sLine)
	local _t = {["current_uid"] = 1, ["current_user"] = 2, ["current_hash"] = 3, ["current_type"] = 4}
	return readLine(getSystemDataDir() .. "temp.dat", _t[sLine])
end

function readSystemData(sLine)
	local _t = {["version"] = 1, ["modem_port"] = 2, ["modem_state"] = 3, ["monitor_port"] = 4, ["monitor_state"] = 5, ["offline"] = 6, ["mainframe_id"] = 7, ["relay_id"] = 8}
	local _s = readLine(getSystemDataDir() .. "pers.dat", _t[sLine])
	if _s ~= "\\" then return _s end
	return nil
end

function writeSystemTemp(sString, sLine)
	local _t = {["current_uid"] = 1, ["current_user"] = 2, ["current_hash"] = 3, ["current_type"] = 4}
	replaceLine(getSystemDataDir() .. "temp.dat", _t[sLine], sString)
end

function writeSystemData(sString, sLine)
	local _t = {["version"] = 1, ["modem_port"] = 2, ["modem_state"] = 3, ["monitor_port"] = 4, ["monitor_state"] = 5, ["offline"] = 6, ["mainframe_id"] = 7, ["relay_id"] = 8}
	replaceLine(getSystemDataDir() .. "pers.dat", _t[sLine], sString)
end

function clearTemp()
	local tPrograms = list(getTempDir())
	for n = 1, #tPrograms do
		fs.delete(getTempDir() .. tPrograms[n])
	end
	fWrite(getSystemDir() .. "data/temp.dat", "")
end

function list(sDir)
	local tAll = fs.list(sDir)
	local tFiles = {}
	local tDirs = {}
	for n, sItem in pairs(tAll) do
		if string.sub(sItem, 1, 1) ~= "." then
			local sPath = fs.combine(sDir, sItem)
			if fs.isDir(sPath) then
				table.insert(tDirs, sItem)
			else
				table.insert(tFiles, sItem)
			end
		end
	end
	table.sort(tDirs)
	table.sort(tFiles)
	return tDirs, tFiles
end

function matchFromTable(sString, tTable, nStartPos, bPartial)
	local nStartPos = nStartPos or 1
	local bPartial = bPartial or false
	for n = nStartPos, #tTable do
		local nStart, nEnd = string.find(tTable[n], sString)
		if nStart == 1 and nEnd == #tTable[n] or bPartial == true and nStart then
			return true, n
		end
	end
	return false, nil
end

function seperateString(sString, sSeperator, bInclusive)
	if string.find(string.sub(sSeperator, 1, 1), "[%^%%]") then sSeperator = string.sub(sSeperator, 1, 2)
	elseif string.sub(sSeperator, 1, 1) == "[" then sSeperator = sSeperator
	else sSeperator = string.sub(sSeperator, 1, 1) end
	bInclusive = bInclusive or false
	local tTable = {}
	local nLastSeperator = 0
	local nNextSeperator = 0
	for nChar = 1, #sString do
		local sChar = string.sub(sString, nChar, nChar)
		if string.find(sChar, sSeperator) then
			nNextSeperator = nChar
			table.insert(tTable, string.sub(sString, nLastSeperator + 1, nNextSeperator - 1))
			if bInclusive then table.insert(tTable, sChar) end
			nLastSeperator = nNextSeperator
		end
	end
	if nLastSeperator < #sString then table.insert(tTable, string.sub(sString, nLastSeperator + 1)) end
	repeat
		local _, i = matchFromTable("", tTable)
		if i then
			table.remove(tTable, i)
		end
	until not i
	return tTable
end

function camelCase(sText)
	local tParts = seperateString(sText, "%s")
	local sString = ""
	for n = 1, #tParts do
		sString = sString .. string.upper(string.sub(tParts[n], 1, 1)) .. string.lower(string.sub(tParts[n], 2))
	end
	sString = string.lower(string.sub(sString, 1, 1)) .. string.sub(sString, 2)
	return sString or ""
end

function deCamelCase(sText)
	local tParts = seperateString(sText, "%u", true)
	local sString = ""
	for n = 1, #tParts do
		if string.find(tParts[n], "%u") then
			sString = sString .. " " .. tParts[n]
		else
			sString = sString .. tParts[n]
		end
	end
	sString = string.upper(string.sub(sString, 1, 1)) .. string.sub(sString, 2)
	return sString or ""
end

function backOneDir(sPath)
	local sPath = "/" .. sPath
	local tParts = seperateString(sPath, "/")
	table.remove(tParts, #tParts)
	local sNewPath = "/"
	for n = 1, #tParts do
		sNewPath = sNewPath .. tParts[n] .. "/"
	end
	return sNewPath
end

function iterateThroughDir(sDir, fDirs, fFiles)
	for _, sItem in ipairs(fs.list(sDir)) do
		if fs.isDir(sDir .. sItem) then
			encryptDir(sDir .. sItem .. "/", fDirs, fFiles)
			fDirs()
		else
			fFiles()
		end
	end
end

function scaleBytes(nRawBytes)
	if nRawBytes == "unlimited" then
		return "Unlimited"
	elseif nRawBytes < 1000 then
		return tostring(nRawBytes) .. " B"
	elseif nRawBytes >= 1000 and nRawBytes < 1000000 then
		local nDecimalPoint = string.find(tostring(nRawBytes / 1000), "%.") or #tostring(nRawBytes)
		return string.sub(tostring(nRawBytes / 1000), 1, nDecimalPoint + 1) .. " KB"
	elseif nRawBytes >= 1000000 then
		local nDecimalPoint = string.find(tostring(nRawBytes / 1000000), "%.") or #tostring(nRawBytes)
		return string.sub(tostring(nRawBytes / 1000000), 1, nDecimalPoint + 1) .. " MB"
	end
end