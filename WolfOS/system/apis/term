
native = term.native or term

local redirectTarget = native
local tRedirectStack = {}
local bSyncScreens    -- Determines if I/O is to be synchronized over all objects (monitors and/or the terminal) in the stack.
local bRedirectDims    -- Determines if the dimensions of the last redirect target take precedence over all other objects (monitors and/or the terminal).

-- true: Synchronizes I/O over all screens.
-- false or nil: Only last active screen has I/O interaction.
function syncScreens( bSync )
  bSyncScreens = bSync
end

-- true: Dimensions of the last object (monitor) in the stack take precedence.
-- false or nil: Dimensions of 'native' (terminal) take precedence.
function redirectDims( bRedirect )
  bRedirectDims = bRedirect
end

local function syncedTarget( _sFunction, ... )
  if #tRedirectStack > 0 and not bRedirectDims then redirectTarget[ _sFunction ]( ... ) end
    -- Execute the function call on every object (e.g. monitors) in the stack.
    for i = #tRedirectStack, 2, -1 do    -- We skip the oldest element in the stack, because that will always be 'native' and we'll return that at the end directly.
      tRedirectStack[i][ _sFunction ]( ... )    -- Execute the function call on the current object in the stack.
    end
    
    if not bRedirectDims then
      return native[ _sFunction ]
    else
      native[ _sFunction ]( ... )
      return redirectTarget[ _sFunction ]
    end
end

local function wrap( _sFunction )
	return function( ... )
        if bSyncScreens then
          return syncedTarget( _sFunction, ... )( ... )    -- Sync Screen behaviour.
        else
          return redirectTarget[ _sFunction ]( ... )    -- Native behaviour.
        end
	end
end

local term = {}
term.redirect = function( _object )
	tRedirectStack[#tRedirectStack + 1] = redirectTarget
	redirectTarget = _object
end
term.restore = function()
	if #tRedirectStack > 0 then
		redirectTarget = tRedirectStack[#tRedirectStack] 
		tRedirectStack[#tRedirectStack] = nil
	end
end
for k,v in pairs( native ) do
	if type( k ) == "string" and type( v ) == "function" then
		if term[k] == nil then
			term[k] = wrap( k )
		end
	end
end
	
local env = getfenv()
for k,v in pairs( term ) do
	env[k] = v
end
